(function(){
  var child_process, read_program, edit_program, usage, args, command, file, check_error, edits, i$, len$, arg, ref$, key, value, out$ = typeof exports != 'undefined' && exports || this;
  child_process = require('child_process');
  function noop(err){
    if (!err) {
      return;
    }
    console.error(err);
  }
  function run_child(cmd, args, stdin, cb){
    var child, stderr, stdout;
    child = child_process.spawn(cmd, args);
    stderr = "";
    stdout = "";
    child.stdin.setEncoding('utf8');
    child.stderr.setEncoding('utf8');
    child.stdout.setEncoding('utf8');
    child.stdin.write(stdin);
    child.stdin.end();
    child.stderr.on('data', function(data){
      stderr += data;
    });
    child.stdout.on('data', function(data){
      stdout += data;
    });
    child.on('close', function(return_code){
      var err;
      if (return_code !== 0) {
        err = new Error("mutagen child process exited with error code");
        err.stdout = stdout;
        err.stderr = stderr;
        return cb(err);
      }
      cb(null, stdout);
    });
  }
  read_program = "import sys, json, mutagen, mutagen.asf\nclass CustomEncoder(json.JSONEncoder):\n  def default(self, obj):\n    mappings = {\n      mutagen.asf.ASFUnicodeAttribute: unicode,\n      mutagen.asf.ASFBoolAttribute: bool,\n      mutagen.asf.ASFDWordAttribute: int,\n      mutagen.asf.ASFQWordAttribute: int,\n      mutagen.asf.ASFGUIDAttribute: (lambda obj: \"\"),\n      mutagen.asf.ASFByteArrayAttribute: (lambda obj: \"\"),\n    }\n    try:\n      func = mappings[type(obj)]\n    except KeyError:\n      return json.JSONEncoder.default(self, obj)\n    return func(obj)\neverything = [dict(mutagen.File(path, easy=True) or {}) for path in sys.stdin.read().split(\"\\n\") if path != \"\"]\nprint(json.dumps(everything, cls=CustomEncoder))";
  out$.read = read;
  function read(files, cb){
    cb == null && (cb = noop);
    run_child('python', ['-c', read_program], files.join('\n'), function(err, stdout){
      if (err) {
        return cb(err);
      }
      return cb(null, JSON.parse(stdout));
    });
  }
  edit_program = "import sys, mutagen\nf = mutagen.File(sys.argv[1], easy=True)\nfor name, value in zip(*[iter(sys.argv[2:])]*2):\n  if value != \"\":\n    f[name] = value\n  else:\n    del f[name]\nf.save()";
  out$.edit = edit;
  function edit(file, edits, cb){
    var args, key, value;
    cb == null && (cb = noop);
    args = ['-c', edit_program, file];
    for (key in edits) {
      value = edits[key];
      args.push(key);
      if (value == null) {
        value = "";
      }
      args.push(value);
    }
    run_child('python', args, '', cb);
  }
  if (require.main === module) {
    usage = function(){
      console.log("Usage: read path-to-file\nUsgae: edit path-to-file key=value ...");
      process.exit(1);
    };
    args = process.argv.slice(2);
    command = args.shift();
    file = args.shift();
    if (!file) {
      usage();
    }
    check_error = function(err){
      if (!err) {
        return;
      }
      console.log(err);
      process.exit(1);
    };
    switch (command) {
    case "read":
      read(file, function(err, json){
        check_error(err);
        console.log(json);
      });
      break;
    case "edit":
      edits = {};
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        arg = args[i$];
        ref$ = arg.split("="), key = ref$[0], value = ref$[1];
        edits[key] = value;
      }
      edit(file, edits, check_error);
      break;
    default:
      usage();
    }
  }
}).call(this);
